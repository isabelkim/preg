We used Python and Flask to create an interactive web application. 

For our register and login functions, we created a database called “users,” which stores user login information (the user’s id, their username, and a hash of their password). We created this database so that we can store their log-in information and “remember” user sessions. 

For our journaling feature, we created a database called “journal,” which stores our user’s journal entries. The columns consist of the id of the journal entry, the user’s id (which matches the id column in the users table), the entry’s title, the content of the entry itself, the mood that the user inputted, and the timestamp of the entry. Creating this database ultimately lets us display all of one user’s journal entries on the “Journal” page. Our submitentry function takes in user inputs through a form we created on the “Submit Entry” page and adds the input to the “journal” database. 

For our tracking feature, we created a database called “date,” which stores all our users’ dates of conception. The columns of this database include the id of the conception date, the user’s id, and the month, day, and year of conception. Once users input their conception date on the “Conception” page, their inputs are added to the “date” database (if a user had input a date previously, their new input replaces the old one). This table allows us to reference the date of conception for a specific user so that we can display a description of that user’s fetus’ development stage on the “Tracking” page. We calculated the number of weeks that have passed between the conception date and the present time, and displayed the description for the development stage that matches that number of weeks (using conditional statements in Jinja). 

We displayed information on postpartum depression using HTML because there were no interactive components that required user input. 

For our quiz feature, we used HTML to display quiz content (the questions and buttons for the answer choices) and JavaScript to work with the user’s interactions with the quiz (clicking their answer choices). We created four functions, all of which match to a Hogwarts house. The answer choices for a question each match to one of the four Hogwarts houses (we arbitrarily matched them ourselves), so clicking an answer choice would call one of the 4 functions we created (whichever one it matches to). For example, for our question “choose a drink,” the answer choice “orange juice” matches to Gryffindor, so the Gryffindor function is called if the user clicks the answer choice “orange juice.” In each of the Hogwarts house functions, we added a point to the score for the respective house (so clicking “orange juice” would add 1 point to the Gryffindor score, “g”). These functions also change the color of the clicked button to indicate the user’s choice, and increment the “count” variable which stores the number of questions answered so far. Clicking an answer choice also calls a function called button1 (or button2, button3, etc.) which match the buttons for a specific question. For example, all of the buttons for question 1 call the button1() function on click. These functions disable all of the buttons for the respective question, and also check if the count (number of questions answered) equals 5, which is the total number of questions. In that case, the user must have answered all questions so the function updateResult() is called. This function uses conditionals to determine which Hogwarts house the baby will be in, and changes the website to display that result.